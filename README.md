# Second course
## system-calls

**stat** - вносит в структуру, на которую указывает statbuf, информацию, содержащуюся в файле, связанном с указателем filename. Структура stat определена в sys\stat.h. Структура stat определена в sys\stat.h. 
```
int stat (const char *pathname, struct stat *buf);
```

**lstat** - похожа на stat, но возвращает информацию о символической ссылке, а не о файле на который та указывает. 
```
int lstat(const char *pathname, struct stat *buf);
```

**fstat** - идентичен stat(), но опрашиваемый файл задаётся в виде файлового дескриптора fd. 
```
int fstat(int fd, struct stat *buf);
```

**fstatat** -  Если в pathname задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор dirfd.
Если в pathname задан относительный путь и значение dirfd равно AT_FDCWD, то pathname рассматривается относительно текущего рабочего каталога вызывающего процесса (как stat()). 
```
int fstatat(int dirfd, const char *pathname, struct stat *buf, int flags);
```

**statx** - Эта функция возвращает информацию о файле, сохраняя ее в буфер, на который указывает statxbuf. 
```
int statx(int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *statxbuf);
```

**open** - открывает файл по указанному пути, если файла нет он может его создать. 
Фалги: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_TRUNC, O_EXCL
```
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode); 0644
```

**write** - записать в файловый дескриптор, какое-то количество байтов из буффера.
```
ssize_t write(int fd, const void *buf, size_t count);
```

**close** - закрывает файловый дескриптор, так что он больше не ссылается ни на один файл. 
```
int close(int fd);
```

**dprintf** - записывает выходные данные в файловый дескриптор fd. 
```
int dprintf(int fd, const char *format, ...);
```

**read** - читывает count байт из файла, описываемого аргументом fd, в буфер, на который указывает аргумент buf Указателю положения в файле дается приращение на количество считанных байт. Функция возвращает количество действительно считанных байт. Это количество может быть меньше, чем count, если встретился маркер конца файла или если до того, как было считано count байт, произошла ошибка. В случае ошибки возвращается —1, а 0 возвращается при попытке чтения в конце файла. 
```
int read(int fd, void *buf, unsigned count)
```

**pwrite** - записывает максимум count байтов из буфера buf в файловый дескриптор fd , начиная со смещения offset. Текущая позиция файла не изменяется. 
```
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset); 
```

**pread** - читает максимум count байтов из файлового дескриптора fd, начиная со смещения offset (от начала файла), в буфер, начиная с buf. Текущая позиция файла не изменяется. 
```
ssize_t pread(int fd, void *buf, size_t count, off_t offset); 
```

**fchmod** - изменяет права доступа к файлу, на который указывает открытый файловый дескриптор fd. 
```
int fchmod(int fd, mode_t mode);
```

**futimens** - обновляет временные метки файла с наносекундной точностью. Файл указывается в виде открытого файлового дескриптора в fd. 
```
int futimens(int fd, const struct timespec times[2]);
```

**chown** - Изменяет владельца для файла, задаваемого параметрами path. Только суперпользователь может изменять владельца файла. Владелец файла может изменять группу файла на любую группу, к которой он принадлежит. Суперпользователь может произвольно изменять группу. 
```
int chown(const char *path, uid_t owner, gid_t group);
```

**fchown** - То же самопе что и chown, но файл задается в fd.
```
int fchown(int fd, uid_t owner, gid_t group);
```

**opendir** - открывает поток каталога, соответствующий каталогу name, и возвращает указатель на этот поток. Поток устанавливается на первой записи в каталоге.
```
DIR *opendir(const char *name);
```

**readdir** - возвращает указатель на следующую запись каталога в структуре dirent, прочитанную из потока каталога. Каталог указан в dir. Функция возвращает NULL по достижении последней записи или если была обнаружена ошибка. Библиотека dirent.h и sys/types.h
```
struct dirent *readdir(DIR *dir);
```

**chdir** - изменяет текущий каталог каталог на path. Библиотека unistd.h
```
int chdir(const char *path);
```

**fchdir** - идентично chdir, только каталог задан в виде открытого файлового дескриптора. Библиотека unistd.h
```
int fchdir(int fd);
```

**dirfd** - возвращает файловый дескриптор, связанный с потоком каталога dirp. Этот файловый дескриптор используется внутри функции потоком каталога. В результате он полезен только для функций, которые не зависят и не изменяют положение в файле, например fstat(2) и fchdir(2). Он автоматически закрывается при вызове closedir(3). 
```
int dirfd(DIR *dirp); 
```

**getdents64** -  читает несколько структур linux_dirent из каталога, на который указывает открытый файловый дескриптор fd, в буфер, указанный в dirp. В аргументе count задаётся размер этого буфера. При нормальном завершении работы возвращается количество прочитанных байт. При достижении конца каталога возвращается 0. 
```
int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);
syscall(SYS_getdents64, fdd, buf, BUF_SIZE); //Использовать так

struct linux_dirent64 {
    ino64_t(long)        d_ino;    /* 64-битный номер иноды */
    off64_t(off_t)        d_off;    /* 64-битное смещение следующей структуры */
    unsigned short d_reclen; /* размер этой dirent */
    unsigned char  d_type;   /* тип файла */
    char           d_name[]; /* имя файла (в конце null) */
}
```

**mkdirat** - пытается создать каталог с именем pathname. Если в pathname задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор dirfd.
```
int mkdirat(int dirfd, const char *pathname, mode_t mode);
```

**statvfs** - возвращает информацию о смонтированной файловой системе. path является путём любого файла, расположенного в смонтированной файловой системе. buf является указателем на структуру statvfs.
```
int statvfs(const char *path, struct statvfs *buf);
```

**statfs** - возвращает информацию о запущенной файловой системе. path - путь к любому файлу, который находится в запущенной файловой системе. buf - указатель на структуру statfs.
```
int statfs(const char *path, struct statfs *buf);
```

**inotify_init** - инициализирует новый объект inotify и возвращает фаловый дескриптор связанный с новой очередью событий inodify, а при ошибке -1.
```
int inotify_init(void);
```

**inotify_init1** - если флагов нет (0), то тоже самое что и inotify_init(), IN_NONBLOCK - не блокирующий режим, IN_CLOEXEC 
```
int inotify_init1(int flags);
```

**inotify_add_watch** - добавляет новый watch для инициализированного inotify. Маски: IN_ACCESS - есть доступ, IN_ATTRIB - изменены метаданные, IN_CLOSE_WRITE - файл, открытый для записи, был закрыт,
IN_CLOSE_NOWRITE - файл, не открытый для записи, был закрыт, IN_CREATE - файл/каталог, созданный в наблюдаемом каталоге, IN_DELETE - файл/каталог удален из наблюдаемого каталога, IN_DELETE_SELF- фросмотренный файл/каталог сам был удален, IN_MODIFY - файл был модифицирован, IN_MOVE_SELF - просмотренный файл/каталог сам был перемещен, IN_MOVED_FROM - файл перемещен из наблюдаемого каталога, IN_MOVED_TO - файл перемещен в наблюдаемый каталог, IN_OPEN - файл был открыт. IN_MOVE = IN_MOVED_FROM | IN_MOVED_TO. IN_CLOSE = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE.

```
int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
```

**poll** - он ждёт пока один дескриптор из набора файловых дескрипторов не станет готов выполнить операцию ввода-вывода. nfds -  кол-во элеметов в fds.
```
 int poll(struct pollfd *fds, nfds_t nfds, int timeout);
 
 struct pollfd {
               int   fd;         /* файловый дескриптор */
               short events;     /* запрашиваемые события */ */
               short revents;    /* возвращённые события */
           };
```

**flock** - Устанавливает или снимает advisory (носящую рекомендательный характер) блокировку на открытый файл, заданный файловым дескриптором fd. Параметр operation может принимать одно из следующих значений:
LOCK_SH - Установить разделяемую блокировку. Разделяемую блокировку на заданный файл может держать более чем один процесс. 
LOCK_EX - Установить эксклюзивную блокировку. Только один процесс может держать эксклюзивную блокировку файла. 
LOCK_UN - Удалить существующую блокировку, удерживаемую данным процессом. 

Вызов flock() может быть блокирован, если несовместимый тип блокировки уже удерживается другим процессом. Чтобы выполнить неблокирующий запрос - LOCK_NB.
flok не блокирует файлы на NFS. Используйте вместо этого вызов fcntl
```
int flock(int fd, int operation);
```

**lockf** - интерфейс поверх блокировки fcntl(2). Аргумент fildes является открытым файловым дескриптором. Чтобы установить блокировку с помощью этой функции, файловый дескриптор должен быть открыт с разрешением только на запись (O_WRONGLY) или с разрешением на чтение/запись (O_RDWR). Возвращает 0, в случае ошибки -1. function - значение определяющее действие, которое необходимо предпринять. 
*F_UNLOCK*	Разблокирует заблокированные разделы.
*F_LOCK*		Блокирует раздел для исключительного использования.
*F_TLOCK* 	Проеряет и блокирет раздел для исключительного использования.
*F_TEST* 	Проверяет раздел на наличие блокировок другими процессами.
```
int lockf(int fildes, int function, off_t size); 
```

**fcntl** - выполняет одну из различных дополнительных операций над файловым дескриптором fd. Эта операция определяется содержимым аргумента cmd. При успешном вызове, возвращаемое значение зависит от использованной операции. В случае ошибки, возвращается -1. 
```
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);


struct flock {
    ...
    short l_type;    /* Тип блокировки: F_RDLCK,
                        F_WRLCK, F_UNLCK */
    short l_whence;  /* Как интерпретировать l_start:
                        SEEK_SET, SEEK_CUR, SEEK_END */
    off_t l_start;   /* Начальное смещение для блокировки */
    off_t l_len;     /* Количество байт для блокировки */
    pid_t l_pid;     /* PID процесса блокирующего нашу блокировку
                        (F_GETLK only) */
    ...
};
```

**fdopen** -  Функция fdopen связывает поток с существующим файловым дескриптором fd. Режим mode потока (одно из следующих значений: "r", "r+", "w", "w+", "a", "a+") должен быть совместим с режимом fd. Указатель файловой позиции в новом потоке принимает значение, равное значению fd, а указатели ошибок и конца файла по значению равны нулю. Режимы "w" или "w+" не "урезают" файл. fd не копируется и будет закрыт, когда поток, созданный fdopen, закроется.
```
FILE *fdopen(int fd, const char *mode);
```

**getrlimit и setrlimit** - соответственно, получают и устанавливают ограничения использования ресурсов. Каждому ресурсу назначается мягкое и жёсткое ограничение, определяемое структурой rlimit.

**prlimit** (только в linux) - объединяет и расширяет функции setrlimit() и getrlimit(). Он может использоваться для задания и получения ограничений ресурсов произвольного процесса. Если значение аргумента new_limit не равно NULL, то структура rlimit, на которую он указывает, используется для задания новых значений мягкий и жёстких ограничений для resource. Если значение аргумента old_limit не равно NULL, то успешный вызов prlimit() помещает текущие значения мягких и жёстких ограничений для resource в структуру rlimit, на которую указывает old_limit. 

resourse: *RLIMIT_AS* - максимальный размер доступной процессу памяти, *RLIMIT_CORE* - максимальный размер ядра файла (байты), которй может быть создан процессом, *RLIMIT_CPU* - время выполнения на цп в секундах которое может быть использовано процессом, *RLIMIT_DATA* - максимальный размер раздела данных процкесса в байтах *RLIMIT_FSIZE* - максимальный размер файла в байтах который может быть создан процессом, *RLIMIT_LOCKS* - ограничение на общее количество блокировок, *RLIMIT_MEMLOCK* - максимальное количество байт памяти, которое может быть заблокировано в ОЗУ, *RLIMIT_MSGQUEUE* - ограничение на количество байт, которое может выделяться для очередей сообщений POSIX для вызывающего процесса с реальным идентификатором пользователя.

```
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit, struct rlimit *old_limit); 

struct rlimit {
    rlim_t rlim_cur;  /* мягкое ограничение */
    rlim_t rlim_max;  /* жёсткое ограничение (максимум для rlim_cur) */
};
```
**getpid** - возвращает идентификатор вызвавшего процесса. (Часто используется функциями, которые генерируют уникальные имена временных файлов.) 
```
pid_t getpid(void);
```
**getppid** -  возвращает идентификатор процесса, являющегося родительским по отношению к вызвавшему процессу. 
```
pid_t getppid(void);
```
**getpgid** - возвращает идентификатор группы процессов, к которой принадлежит процесс, указанный pid. Если значение pid равно нулю, то используется идентификатор текущего процесса.
```
pid_t getpgid(pid_t pid);
```
**getsid** - getsid(0) возвращает идентификатор (ID) сессии, вызвавшего процесса. getsid(p) возвращает идентификатор сессии процесса с номером p. (Идентификатор сессии процесса - это идентификатор группы процесса, который является лидером сессии). В случае ошибки будет возвращено значение -1.
```
pid_t getsid(pid_t pid);   
```
**getuid** - возвращает фактический идентификатор ID пользователя в текущем процессе.

**geteuid** - возвращает эффективный идентификатор ID пользователя в текущем процессе. 
```
uid_t getuid(void);
uid_t geteuid(void);
```

**getgid** - возвращает действительный идентификатор группы текущего процесса.

**getegid** - возвращает еффективный идентификатор группы текущего процесса. 
```
gid_t getgid(void);
gid_t getegid(void);   
```

**sched_getattr** -  возвращает алгоритм планирования и соответствующие атрибуты для нити с идентификатором pid. Если pid равно нулю, то будет возвращён алгоритм и атрибуты планирования вызывающей нити. В size должен быть задан размер структуры sched_attr. flags предназначен для расширения интерфейса в будущем; в текущей реализации его значение должно быть равно 0.
```
int sched_getattr(pid_t pid, struct sched_attr *attr, unsigned int size, unsigned int flags);

struct sched_attr {
               u32 size;              /* Size of this structure */
               u32 sched_policy;      /* Policy (SCHED_*) */
               u64 sched_flags;       /* Flags */
               s32 sched_nice;        /* Nice value (SCHED_OTHER,
                                         SCHED_BATCH) */
               u32 sched_priority;    /* Static priority (SCHED_FIFO,
                                         SCHED_RR) */
               /* Remaining fields are for SCHED_DEADLINE */
               u64 sched_runtime;
               u64 sched_deadline;
               u64 sched_period;
           };
```

**sched_getparam** - олучает текущие параметры планирования процесса с pid. Если pid равен нулю, то возвращаются параметры вызывающего процесса. 
```
int sched_getparam(pid_t pid, struct sched_param *param);

struct sched_param {
    ...
    int sched_priority;
    ...
};
```
